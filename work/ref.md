思考：
·主体思路：
    初始化两个集合 ——> 求交并差集 
    初始化另一个集合 ——> 求幂集 ——> 求n元子集

实验一 求任意两个集合的交、并和差集
    ·本实验不需要考虑这两个集合是否有序，可以使用哈希/无序集合。
    ·交、并和差集都涉及到判断元素是否在集合内，用 集合名.find(元素) 的方式进行判断。
    ·集合初始化：
        ·从键盘输入 任意两个集合 的值，
            ·目前，我只想到通过每次插入一个元素（可以是n元集合）的方式进行初始化。
            ·除了直接通过插入初始化集合，还可以用其他容器（如vector）进行初始化，然后转为集合。
                e.g vector<int> vec = {1,2,3};
                    unordered_set<int> uset(vec.begin(),vec.end());
        此外，定义一个集合作为求解出的新集合。
    ·每个集合元素的遍历方式：
        for (const auto& element : mySet){
            <!-- 这是逐个输出元素的写法 -->
            <!-- cout << element << " "; -->
        }
    ·无序集合的输出形式（小括号？中括号？）：{元素}
    **函数设计**

实验二 求任意一个集合的幂集
    ·求集合的幂集
        ·计算原集合元素个数，以判断幂集中元素的个数
            ·最开始准备遍历用计数器记录，奈何时间复杂度太高。查找资料知，通常将size()方法与empty()方法结合使用。
        ·遍历插入幂集元素（？）
    **函数设计**

实验三 求任意一个集合的m元子集
根据实验二求出的幂集，选择（感觉依旧遍历，检查每个幂集元素中子元素的个数）满足条件的子集合。
    **函数设计**
    

要引入的库：
#include <iostream>
#include <unordered_set>
#include <set>
<!-- 依旧可以用位运算替代 -->
#include <cmath> 

个人感受：
比上次的实验，这次的实验我写起来轻松得多，也许是对集合的操作更熟悉了吧。

在编写程序的过程中遇到的问题：
    1.关于面向对象编程的问题：
        a.静态函数不能直接调用类（如r1）的私有成员，只能创建一个r1类的对象，对新建的对象进行操作。
        b.非静态函数可以直接调用类的私有成员，但在调用前需要使该私有成员不为空。